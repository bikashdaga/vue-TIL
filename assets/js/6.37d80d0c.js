(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{393:function(t,s,a){t.exports=a.p+"assets/img/short.1f0a5f63.jpg"},430:function(t,s,a){t.exports=a.p+"assets/img/dag.65fba511.jpg"},431:function(t,s,a){t.exports=a.p+"assets/img/cal1.848c57cf.jpg"},432:function(t,s,a){t.exports=a.p+"assets/img/cal2.18b0732b.jpg"},433:function(t,s,a){t.exports=a.p+"assets/img/d1.044a0c6c.jpg"},434:function(t,s,a){t.exports=a.p+"assets/img/d2.220303c5.jpg"},435:function(t,s,a){t.exports=a.p+"assets/img/d3.0427d402.jpg"},436:function(t,s,a){t.exports=a.p+"assets/img/d4.b3479577.jpg"},437:function(t,s,a){t.exports=a.p+"assets/img/d5.a623f012.jpg"},438:function(t,s,a){t.exports=a.p+"assets/img/d6.55ff9bd9.jpg"},439:function(t,s,a){t.exports=a.p+"assets/img/d7.0587c29c.jpg"},596:function(t,s,a){"use strict";a.r(s);var n=a(21),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"그래프-위상-정렬"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#그래프-위상-정렬"}},[t._v("#")]),t._v(" 그래프 위상 정렬")]),t._v(" "),n("h3",{attrs:{id:"dag"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dag"}},[t._v("#")]),t._v(" DAG")]),t._v(" "),n("p",[t._v("DAG는 사이클이 없는 방향 그래프를 의미한다.")]),t._v(" "),n("p",[n("img",{attrs:{src:a(430),alt:"dag"}})]),t._v(" "),n("p",[t._v("위 DAG 그래프를 차례로 순회할때 정렬되는 노드를 표현하면")]),t._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("A\n|-- C --|\n|       |-- B -- F-- D -- I -- G\n|                |-- H (H 먼저 완료 후)\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br")])]),n("p",[t._v("DAG 순회의 가장 중심이 될 규칙은 "),n("strong",[t._v("자신을 가리키는 노드들이 모두 인접한 노드의 순회를 끝마친 상태여야 한다는 것")]),t._v("이다.")]),t._v(" "),n("p",[t._v("규칙에 따라 DAG를 순회하다 보면 동일한 위상을 갖는 "),n("strong",[t._v("H,D")]),t._v(" 노드를 볼 수 있는데, 이로 인해 DAG 순회의 결과 노드집합은 여러 경우를 가질 수 있다.")]),t._v(" "),n("p",[t._v("(A -> C -> B -> F -> "),n("strong",[t._v("D -> H")]),t._v(" -> I -> G)")]),t._v(" "),n("p",[t._v("(A -> C -> B -> F -> "),n("strong",[t._v("H -> D")]),t._v(" -> I -> G)")]),t._v(" "),n("p",[t._v("이러한 정렬 방법을 "),n("strong",[t._v("위상 정렬(topological sorting)")]),t._v(" 이라고 한다.")]),t._v(" "),n("p",[t._v("DFS 기반으로 "),n("strong",[t._v("pre/post")]),t._v(" 변수를 통해 그래프 순회를 하고 "),n("strong",[t._v("post")]),t._v("값이 내림차순으로 정렬 되도록 노드를 나열하면 된다.")]),t._v(" "),n("h3",{attrs:{id:"weighted-dag"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#weighted-dag"}},[t._v("#")]),t._v(" Weighted DAG")]),t._v(" "),n("p",[t._v("가중치가 있는 DAG에서 최장경로를 구하는 문제가 있다. DAG 순회 방식을 채택한 뒤, 정점 v에서 w까지 가는 동안 각 인접 노드를 순회할 때 가중치가 가장 크게 잡히는 경로부터 순회하면 된다.")]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[t._v("algorithm findLongestPath"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("인접 리스트"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 노드 수 n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 정점 w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 정점 t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 최장경로 저장 배열 arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    정점 w "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"visited"')]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("정점 w "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" 정점 t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" 최장 경로 길이는 "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("노드의 인접리스트가 없을 때까지"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        정점 v 선언"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" w로 초기화 "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("w부터 인접한 노드들을 재귀적으로 v를 통해 순회할 예정"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" visited"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 재귀호출, w -> v까지 가는 동안의 최장경로")]),t._v("\n            findLongestPath"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("인접 리스트"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 최장경로 저장 배열 arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 현재 노드인 w까지의 최장경로와 w에서 v까지의 최장 경로 길이를 비교")]),t._v("\n            arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("max")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("weight"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("//")]),t._v(" w 인접노드인 v가 방문노드\n            "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# v가 이미 방문한 노드이므로 해당 노드까지의 최장경로 비용이 저장되어 있음")]),t._v("\n            arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("max")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("weight"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n        v "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" w의 또 다른 인접노드\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br"),n("span",{staticClass:"line-number"},[t._v("16")]),n("br"),n("span",{staticClass:"line-number"},[t._v("17")]),n("br"),n("span",{staticClass:"line-number"},[t._v("18")]),n("br"),n("span",{staticClass:"line-number"},[t._v("19")]),n("br"),n("span",{staticClass:"line-number"},[t._v("20")]),n("br"),n("span",{staticClass:"line-number"},[t._v("21")]),n("br"),n("span",{staticClass:"line-number"},[t._v("22")]),n("br")])]),n("p",[t._v("Weighted DAG의 최종 수행시간은 O(n+m)이 된다.")]),t._v(" "),n("h2",{attrs:{id:"bellman-ford-알고리즘"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bellman-ford-알고리즘"}},[t._v("#")]),t._v(" Bellman Ford 알고리즘")]),t._v(" "),n("p",[t._v("Bellman Ford 알고리즘은 그래프 최단 경로 알고리즘 중 하나이다.")]),t._v(" "),n("p",[t._v("아래 그래프를 고려하자.")]),t._v(" "),n("p",[n("img",{attrs:{src:a(393),alt:"shortest"}})]),t._v(" "),n("p",[t._v("단순 노드의 개수로 최단 경로를 구하면")]),t._v(" "),n("p",[n("strong",[t._v("(a -> b -> f -> g -> i)")]),t._v(" 또는")]),t._v(" "),n("p",[n("strong",[t._v("(a -> c -> e -> h -> u)")]),t._v(" 가 된다.")]),t._v(" "),n("p",[t._v("하지만 각 엣지마다 가중치가 부여되어 있기 때문에 이를 고려하여 최단 경로를 구하면")]),t._v(" "),n("p",[n("strong",[t._v("(a -> c -> b -> f -> g -> i)")]),t._v(" 로 길이가 12가 된다.")]),t._v(" "),n("p",[t._v("이를 재귀적으로 생각하면 "),n("strong",[t._v("(a->i)")]),t._v(" 로 가는 최단 경로는 "),n("strong",[t._v("(a -> g)")]),t._v(" 까지의 최단 경로 + "),n("strong",[t._v("(g->i)")]),t._v(" 까지의 엣지 가중치 값이다.")]),t._v(" "),n("p",[t._v("이를 정리하여 "),n("code",[t._v("dist[v] = s(source)에서 v로 가는 최단 경로의 길이")]),t._v(" 로 정의할 수 있다.")]),t._v(" "),n("p",[t._v("또한 목적지 v에 인접하면서 v를 가리키는 노드들이 존재한다면")]),t._v(" "),n("p",[n("code",[t._v("dist[v] = min(dist[u1] + w(u1,v), dist[u2] + w(u2, v), dist[u3] + w(u3, v))")]),t._v(" 로 정의할 수 있다.")]),t._v(" "),n("p",[t._v("또한, 최종적으로 u1, u2, u3 등 목적지 직전 인접 노드까지 최단경로를 모두 계산한 값이 목적지 노드에서의 계산된 최단 경로의 길이보다 작다면 이를 인접 노드까지의 최단 경로 값으로 새롭게 초기화한다. 이를 "),n("strong",[t._v("릴랙스 relax(u, v)")]),t._v(" 라고 표현한다.")]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# relax!!")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br")])]),n("p",[t._v("초기에 각 노드의 계산된 최단 경로 길이값을 "),n("code",[t._v("math.inf")]),t._v("로 초기화한 뒤에 최단경로를 계산하며 각각 릴랙스처리 해주면 된다.")]),t._v(" "),n("p",[t._v("다음은 위 최단경로 알고리즘의 예시이다.")]),t._v(" "),n("p",[n("img",{attrs:{src:a(431),alt:"cal1"}})]),t._v(" "),n("p",[t._v("노드 b와 노드 c가 각각 5, 1값으로 초기화 되었다.")]),t._v(" "),n("p",[n("img",{attrs:{src:a(432),alt:"cal2"}})]),t._v(" "),n("p",[n("strong",[t._v("(a -> c -> b)")]),t._v(" 경로의 가중치 계산 값에 따라 현재 b가 갖는 가중치 값인 5보다 "),n("strong",[t._v("(a -> c -> b)")]),t._v(" 경로의 가중치 값이 더 작으므로 4라는 값으로 새롭게 초기화 된다.")]),t._v(" "),n("p",[t._v("최단경로를 계산하기 위해 거치는 노드는 소스 노드(Source)와 목적지 노드 (V)를 제외하여 총 "),n("strong",[t._v("n-2")]),t._v(" 개를 넘지 않는다.")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),n("p",[t._v("가령 소스노드 S로부터 목적지 노드 V까지의 최단 경로를 계산하는 상황을 고려해보자. S부터 V까지 전체 노드의 개수는 n개일 때\n"),n("strong",[t._v("S를 제외한 n-1개의 노드가 릴랙스 되어야 하므로")]),t._v(" n-1 라운드를 마련하여 루프를 돌린다.")]),t._v(" "),n("p",[t._v("최단경로 계산이 되지 않은 무작위 노드들은 "),n("code",[t._v("math.inf")]),t._v(" 끼리 연산이 되므로 릴랙스에 의미가 없다.")]),t._v(" "),n("p",[t._v("또한 각 라운드마다 모든 엣지에 대해 릴랙스 해주어야 한다. 이를 n-1 라운드 동안 진행한다.")])]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# n-1 round")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each edge"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" G"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" w"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# relax(u, v)")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br")])]),n("p",[t._v("위의 이중루프가 "),n("strong",[t._v("Bellman-Ford 알고리즘")]),t._v(" 이며, 총 수행시간은 O(n X E) (E는 전체 엣지 수)이고 엣지는 최대 n의 제곱만큼 생성될 수 있으므로\nO(n³)이 된다.")]),t._v(" "),n("h2",{attrs:{id:"dijkstra-알고리즘"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dijkstra-알고리즘"}},[t._v("#")]),t._v(" Dijkstra 알고리즘")]),t._v(" "),n("p",[n("img",{attrs:{src:a(393),alt:"short"}})]),t._v(" "),n("p",[t._v("위의 벨만 포드 알고리즘은 수행시간이 너무 느리다. 이에 비해 더 빠른 "),n("strong",[t._v("다익스트라(Dijkstra) 알고리즘")]),t._v(" 을 알아본다.")]),t._v(" "),n("p",[t._v("먼저 슈도 코드를 살펴보면")]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[t._v("Q "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" min_heap "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 최소 힙")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" Q "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" ∅ "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 힙에 원소가 없을 때까지")]),t._v("\n    u "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Q"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("deleteMin"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each u"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# u에 인접한 모든 노드들에 대해")]),t._v("\n        relax"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        Q"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decreaseKey"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# heapify Up - O(logn)")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("p",[t._v("위 알고리즘에 따라 노드를 순회하면")]),t._v(" "),n("figure",{staticStyle:{display:"flex","align-items":"center","flex-direction":"column"}},[n("img",{attrs:{src:a(433),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("1")]),t._v(" "),n("img",{attrs:{src:a(434),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("2")]),t._v(" "),n("img",{attrs:{src:a(435),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("3")]),t._v(" "),n("img",{attrs:{src:a(436),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("4")]),t._v(" "),n("img",{attrs:{src:a(437),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("5")]),t._v(" "),n("img",{attrs:{src:a(438),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("6")]),t._v(" "),n("img",{attrs:{src:a(439),height:"80%",width:"80%"}}),t._v(" "),n("figcaption",{staticStyle:{"font-size":"1rem",color:"grey","font-weight":"bold","margin-top":"0.8rem","margin-bottom":"1rem"}},[t._v("7")])]),t._v(" "),n("p",[t._v("최소 힙 자료구조는 "),n("a",{attrs:{href:"https://www.geeksforgeeks.org/min-heap-in-python/",target:"_blank",rel:"noopener noreferrer"}},[t._v("다음을 참조한다."),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("수행시간의 경우 각 노드가 모두 "),n("strong",[t._v("최소 힙에 한 번의 삽입과 한 번의 삭제가 이루어지므로 O(nlogn)")]),t._v(" 시간이 소요되고")]),t._v(" "),n("p",[t._v("각 에지가 모두 릴랙스 후 "),n("code",[t._v("heapify up")]),t._v("연산을 진행하므로 "),n("strong",[t._v("O(E x logn) = O(n²logn)")]),t._v(" 시간이 소요된다.")]),t._v(" "),n("p",[t._v("따라서 총 소요시간은 "),n("strong",[t._v("O(n²logn)")]),t._v(" 가 된다.")]),t._v(" "),n("h3",{attrs:{id:"dijkstra-구현-코드"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dijkstra-구현-코드"}},[t._v("#")]),t._v(" Dijkstra 구현 코드")]),t._v(" "),n("div",{staticClass:"language-python line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[t._v("s "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# s is source node")]),t._v("\ndist "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("∞"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("∞"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("∞"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("∞"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nparent "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# parent를 통해 최단경로를 구성한다!")]),t._v("\nmin_heap Q  "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("all")]),t._v(" nodes v "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v(" key dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" Q "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("is")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" empty"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    u "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Q"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("deleteMin"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each edge u"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        relax"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# relax 하면서 parent에 데이터를 추가한다.")]),t._v("\n        Q"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decreaseKey"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" Q\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" dist"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" parent\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br")])]),n("p",[n("strong",[t._v("parent")]),t._v(" 리스트가 바로 그래프 무작위 노드에서 노드로의 최단경로를 표현해둔 데이터이다.")])])}),[],!1,null,null,null);s.default=e.exports}}]);